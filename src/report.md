# Basic CI/CD

Разработка простого **CI/CD** для проекта *SimpleBashUtils*. Сборка, тестирование, развертывание.

# Part 1. Настройка **gitlab-runner**

## Поднять виртуальную машину *Ubuntu Server 20.04 LTS*

![Ubuntu](images/1.png)  

## Скачать и установить на виртуальную машину **gitlab-runner**

Для начала ставим на машину нужные для сборки пакеты

`sudo apt install gcc`

`sudo apt install make`

`sudo apt install clang-format`

Ставим гитлаб раннер

`sudo apt install gitlab-runner`

![gitlab-runner](images/2.png)  

`sudo gitlab-runner start`

При попытке запуска вылетает ошибка 0000

![gitlab-runner 2](images/3.png)  

Установленный сейчас пакет gitlab-runner из репозитория версия 11.2.0, которая не поддерживается Gitlab.

![gitlab-runner 3](images/4.png)  

Статья с решением https://stackoverflow.com/questions/65206569/getting-docker-error-while-using-shell-gitlab-runner-erro0000

Устанавливаем последнюю версию gitlab-runner с использованием команд:

`sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64"`

`sudo chmod +x /usr/local/bin/gitlab-runner`

`sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash`

`sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner`

![gitlab-runner 4](images/5.png)  

`sudo gitlab-runner start`

`sudo systemctl enable --now gitlab-runner`

## Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)
- Для регистрации используется URL и токен, с странички задания на платформе.

`sudo gitlab-runner register`

Далее указываем УРЛ

Токен 

Описание например - DO6_CICD progect

Теги build,style,test,deploy

Опици - пропускаем

Выбираем терминал шелл

`sudo gitlab-runner verify`

`sudo gitlab-runner run`

# Part 2. Сборка

## Написать этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*:

## В файле _gitlab-ci.yml_ добавить этап запуска сборки через мейк файл из проекта _C2_

## Файлы, полученные после сборки (артефакты), сохранять в произвольную директорию со сроком хранения 30 дней.

Создаём файл `.gitlab-ci.yml` в корне проекта и вписываем туда следующее:  

![.gitlab-ci.yml](images/6.png)  

Далее добавляем в `src` `cat` `grep` из проекта `SimpleBash`, пушим и проверяем работу:  

![lab 1](images/7.png)  

![lab 2](images/8.png)  

![lab 3](images/9.png)  

# Part 3. Тест кодстайла

## Написать этап для **CI**, который запускает скрипт кодстайла (*clang-format*):

Для этого пишем дополнительный этап в _gitlab-ci.yml_

![.gitlab-ci.yml](images/10.png)  

Проверяем результат, для этого я специально испортил формат кэт 

![lab 4](images/11.png)  

Как видим - проверка прошла - внутри пайплайна есть отображение код стайла

## Если кодстайл не прошел, то "зафейлить" пайплайн

Для этого нам необходимо поймать вывод утилиты *clang-format* и завершить если он есть. 

Проверяем вывод 

![lab 5](images/12.png)  

## В пайплайне отобразить вывод утилиты *clang-format*

`clang-format -n -style=google src/**/*.c src/**/*.h` давет вывод в пайплайне

# Part 4. Интеграционные тесты

## Написать этап для **CI**, который запускает ваши интеграционные тесты из того же проекта:

## Запускать этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно

## Если тесты не прошли, то "зафейлить" пайплайн

## В пайплайне отобразить вывод, что интеграционные тесты успешно прошли / провалились

Тесты грепа и кета выводят сями по себе результат, по этому пайплайне есть результаты 

Итог выполнения тестов выдает в окружение 1 или 0, в кэт пришлось дописать это, по нему выбиваем ошибку 

Также сборка выдает в окружение 1 или 0

![.gitlab-ci.yml](images/13.png)  

Тесты были ориентированы под мак, по этому на линукс часть фейлится, проверим работу ошибки

![lab 6](images/14.png)  

Исправляем - проверяем 

![lab 7](images/15.png)  

# Part 5. Этап деплоя

`-` Для завершения этого задания вы должны перенести исполняемые файлы на другую виртуальную машину, которая будет играть роль продакшена

## Поднять вторую виртуальную машину *Ubuntu Server 20.04 LTS*

![Ubuntu](images/16.png) 

## Написать этап для **CD**, который "разворачивает" проект на другой виртуальной машине:

Для этого нам необходимо соедить 2 вируальные машины для возможности предачи данных

Настриваем сеть на тип соединения сетевой мост 

![lan](images/17.png) 

Таком образом все вируальные машины находятся напрямую в локальной сети 

Запрашиваем новые айпи адреса для машин и пингуем их чтобы проверить соединение 

![lan](images/18.png) 

Разворачивание проекта на другой машине будет осуществлятся через ssh туннель.

Сложность этого этапа в провах доступа. Каждый раз запуская скрипт нам требуется доступ к папкам на удаленном сервере. 

Все работы выполняет gitlab-runner обычно через своего одноименного пользователя. 

Необходимо на сервере где запущен gitlab-runner сменить пользователя на gitlab-runner командой 

Но у него нет пароля - даем ему пароль через рут sudo su далее passwd gitlab-runner

Также нужны права - sudo su -l gitlab-runner -s /bin/bash

`su - gitlab-runner`

далее сгенерировать ssh ключ. 

`ssh-keygen`

![lan](images/19.png) 

Полученный ключ необходимо внести в файл /.ssh/authorized_keys на удаленном сервере.

Для этого вооспользуемся командой ssh-copy-id user@host где юзер - имя пользователя сервера, хост  - адрес сервера

Однако в моем случае данные оцедуры выполнял пользователь root 

![lan](images/20.png) 

По этому ключ необходимо было сделать от пользователя рут sudo su и повторяем предидущие шаги 

После появилась проблема с доступом к папкам на второй машине - не удовалось переместить файлы для этого 

Делаем владельцем директории навторой машине пользователя с первой командой 

`sudo chown -R $(whoami) путь`

## Написать bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины

![bash-скрипт](images/22.png) 

## Запускать этот этап вручную при условии, что все предыдущие этапы прошли успешно

## В файле _gitlab-ci.yml_ добавить этап запуска написанного скрипта

![_gitlab-ci.yml_](images/23.png) 

## В случае ошибки "зафейлить" пайплайн

В результате вы должны получить готовые к работе приложения из проекта *C2_SimpleBashUtils* (s21_cat и s21_grep) на второй виртуальной машине.

![lab 8](images/21.png) 

![lab 9](images/23.png) 

# Part 6. Дополнительно. Уведомления

## Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем "[ваш nickname] DO6 CI/CD" в *Telegram*

Для этого нам необходимо создать бота в ТГ 
это можно сделать через бота BotFather 

![TG](images/28.png) 

Пишем боту команды, следуем интрукциям - появлется чат с ботом

Далее идем по адресу https://api.telegram.org/botBOT_TOKEN/getUpdates

Пишем своему боту чтобы проверить соединение и видим текст сообщения  - содиенение готово, берем из него айди чата

![TG 2](images/27.png) 

Далее у нас есть ади чата и токен, для отправки сообщений ботом

На сайте https://api.telegram.org/botBOT_TOKEN/sendMessage передать тест сообщения и айди чата 

Пишем скрипт который мы будем запускать по завершению каждого этапа для отправки результата 

![TG.sh](images/29.png) 

добавляем в файл  _gitlab-ci.yml_ зпуск скрипта после выполенения этапа 

![TG_gitlab-ci.yml](images/30.png) 

- Текст уведомления должен содержать информацию об успешности прохождения как этапа **CI**, так и этапа **CD**.

![TG 3](images/26.png) 
